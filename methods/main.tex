\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{fancyvrb}
\usepackage{natbib}
\bibliographystyle{unsrtnat}
\usepackage{amsmath,amssymb}
\DeclareMathOperator{\se}{\textrm{se}}
\title{Supplementary Methods}
\author{Michael I. Love}
\begin{document}
\maketitle
\section{MRLocus statistical model}

MRLocus proceeds in two separate hierarchical models, which are
encoded in the Stan programming language and with posterior
inference performed using the Stan and RStan software packages
\citep{stan,rstan}. In section \ref{sec:coloc} we define the
model for the colocalization step, and in section \ref{sec:slope} we
define the model for the slope fitting step.

\subsection{Colocalization step} \label{sec:coloc}

\subsubsection{Input data}

The first step performs colocalization of eQTL (A) and GWAS (B)
signals across a number of LD-independent signal clusters
$j \in 1,\dots,J$, using summary statistics from both studies:
$\widehat{\beta}^A_{i,j}$ and $\se(\widehat{\beta}^A_{i,j})$
for SNP $i \in 1,\dots,n_j$ in cluster $j$ for study A,
and the respective LD matrices for each clump $j$:
$\Sigma_j^A$ and $\Sigma_j^B$.
The estimated coefficients $\widehat{\beta}^X_{i,j}$ for
$X \in \{A,B\}$ refer to either the estimated coefficients from a
linear model of a continuous trait $y$ on genotype dosages
$\{0,1,2\}$, or the estimated log odds from a logistic regression of a
binary trait $y$ modeled on genotype dosages. While it would be
preferable to use allelic fold change (aFC) \citep{aFC} or ACME effect sizes
\citep{ACME} for the eQTL (A) study in MRLocus modelinge, in practice
we typically are provided with publicly available estimated
coefficients representing log expression values on genotype dosages.

The eQTL and GWAS studies are referred to as ``A'' and ``B'' in the
formula and code below for generalization, for example, the eQTL study
could be replaced with a pQTL (protein quantitative trait loci)
study. ``A'' therefore refers to a study of a trait that is believed
to be causally upstream of the trait examined in study ``B''.

\subsubsection{Collapsing and allele flipping}

MRLocus contains two convenience functions,
\texttt{collapseHighCorSNPs} and \texttt{flipAllelesAndGather}, which
are described briefly. The first function uses hierarchical clustering
based on the LD matrix (the user must pick which to use if two are
available), in order to collapse SNPs into groups using complete
linkage, and thresholding the resulting dendrogram at 0.95
correlation. The SNP with the highest absolute $z$-score within a
collapsed set is chosen as the representative SNP.

\texttt{flipAllelesAndGather} performs a number of allele flipping
steps for assisting statistical modeling and visualization. The
alleles are flipped such that the index SNP (as defined by its
absolute value of $z$-score) for study A has a positive estimated
coefficient. This is to simplify the interpretations of the plots --
such that we are always describing the effects on downstream traits
for expression increasing alleles. Additionally, we flip alleles such
that SNPs with positive correlation of genotypes in either
$\Sigma_j^A$ or $\Sigma_j^B$ (the user must pick which to use) are
kept as-is, while SNPs with negative correlation of genotypes have
their alleles flipped. Allele flipping obviously involves both keeping
track of the reference and effect allele, as well as multiplication of
the estimated coefficient by -1. This function also performs checks
such that the A and B study agree in terms of the effect and reference
allele.

\subsubsection{Scaling}

In practice, before supplying
$\widehat{\beta}^A_{i,j}$ and $\widehat{\beta}^B_{i,j}$
and the associated standard errors to the hierarchical model, the
values are scaled such that the index SNP (as defined by its absolute
value of $z$-score) for study A has estimated coefficient of $\pm 1$ for
both study A and B. If two or more SNPs have the same $z$-score, the
first is chosen.  This simplifies the Stan code and improves model
fit, as the two studies are then at comparable scale. The scaling is
reversed after the Stan model is fit.
For the user-input estimated coefficients and standard errors for
study $X \in \{A,B\}$ and clump $j$,
$\widehat{\beta}^{X,input}_{i,j}$ and $\se(\widehat{\beta}^{X,input}_{i,j})$,
in the first step we create scaled estimated coefficients:

\begin{align}
  z^*_j &= \max_i \left( |\widehat{\beta}^{A,input}_{i,j}|/\se(\widehat{\beta}^{A,input}_{i,j}) \right) \\
  i^*_j &= \min \left(i \in 1,\dots,n_j \right) \  s.t. \  |\widehat{\beta}^{A,input}_{i,j}|/\se(\widehat{\beta}^{A,input}_{i,j}) = z^*_j \\
  s^X_j &= 1/|\widehat{\beta}^{X,input}_{i^*,j}| \\
  \widehat{\beta}^X_{i,j} &= s_j \widehat{\beta}^{X,input}_{i,j}, \; i \in 1,\dots,n_j \\
  \se(\widehat{\beta}^X_{i,j}) &= s_j \se(\widehat{\beta}^{X,input}_{i,j}), \; i \in 1,\dots,n_j
\end{align}

Note that equations (1-2) refer specifically to study A, while
equations (3-5) refer to steps that are repeated for $X=A$ and
$X=B$. Again, in words, $i^*_j$ is the index of the first occurrence of
the maximal value of absolute value of $z$-score in study A and clump
$j$.

\subsubsection{Colocalization}

In the following equations, $\widehat{\beta}^X_{i,j}$ and
$\se(\widehat{\beta}^X_{i,j})$ refer to these scaled estimates as
described in the previous section, but in the following section
\ref{sec:slope} on slope fitting, the values are transformed back to
the original scale by multiplying by $1/s^X_j$ for $X \in \{A,B\}$
respectively.

We use a statistical model for the summary statistics motivated by the
eCAVIAR model \citep{eCAVIAR}. In eCAVIAR, the summary statistic
$z$-scores in a vector $S$ are modeled as a multivariate normal
distribution with mean vector $\Sigma \Lambda$ and covariance matrix
$\Sigma$, where $\Lambda$ is a vector giving the true standardized
effect sizes. In a locus with a single causal SNP producing the
observed enrichment of signal, and if the causal SNP is in the set
modeled by eCAVIAR, the vector $\Lambda$ would consist of a vector
with all 0 values except for one SNP with non-zero value.
eCAVIAR then models $\Lambda$ with a multivariate normal prior
distribution centered on 0 with covariance matrix based on a vector of
0's and 1's giving the true causal status of the SNPs in the locus and
a preset scale parameter determined from previous studies.

Here MRLocus diverges from eCAVIAR in two ways. Firstly, we will use a
generative model for the elements in the vector
$\widehat{\beta}_{\centerdot,j}$ conditional on the true effect sizes
$\beta_{\centerdot,j}$ within LD-independent signal cluster
$j$ (effect sizes rather than $z$-scores).
Secondly, we will use a univariate distribution for each
$\widehat{\beta}^X_{i,j}$ instead of a multivariate for the entire
vector. This second choice was a practical one, as it provided more
efficient model fitting with Stan, and allowed for more flexible
choice of priors, as described below. 

Instead of a multivariate normal prior on the estimate coefficients,
MRLocus uses a horseshoe prior \citep{horseshoe1,horseshoe2}, which is
a type of hierarchical shrinkage prior that provides sparsity in the
posterior estimates \citep{hiershrink}. In the following, we use the
notation of \citet{horseshoe1}, where $\lambda_i$ provides the
\emph{local} shrinkage parameters and $\tau$ provides the
\emph{global} shrinkage parameter.

The following hierarchical model is fit separately across
LD-independent signal clusters $j \in 1,\dots,J$, and so in the
following equations, the subscript for $j$ is omitted for clarity. In
all equations below but the last, $i \in 1,\dots,n_j$. Here, for
consistency with Stan code, the normal distribution is written as
$N(\mu,\sigma)$ where the second element $\sigma$ provides the
standard deviation. 

\begin{align}
  \widehat{\beta}^A_i &\sim N([\Sigma^A \beta^A]_i, \se(\widehat{\beta}^A_i)) \\
  \widehat{\beta}^B_i &\sim N([\Sigma^B \beta^B]_i, \se(\widehat{\beta}^B_i)) \\
  \beta_i^A &\sim N(0, \lambda_i \tau) \\
  \beta_i^B &\sim N(0, \lambda_i \tau) \\
  \lambda_i &\sim \textrm{Cauchy}(0,1) \\
  \tau &\sim \textrm{Cauchy}(0,1)
\end{align}

Of note, $\beta_i^A$ and $\beta_i^B$ share a prior involving
$\lambda_i$, such that evidence from study A and B supporting a
SNP $i^\dagger$ that is causal both for eQTL and GWAS signal
($\beta_{i^\dagger}^A \ne 0, \beta_{i^\dagger}^B \ne 0$),
will be reflected in larger posterior draws for $\lambda_{i^\dagger}$
compared to other $\lambda_{i'}$ for $i' \ne i^\dagger$.

\subsection{Slope fitting step} \label{sec:slope}

\newpage

\section{MRLocus stan code}

\subsection{Colocalization step}

\texttt{inst/stan/beta\_coloc.stan}

\begin{Verbatim}[frame=single,numbers=left]
data {
  int n;
  vector[n] beta_hat_a;
  vector[n] beta_hat_b;
  vector[n] se_a;
  vector[n] se_b;
  matrix[n,n] Sigma_a;
  matrix[n,n] Sigma_b;
}
parameters {
  vector[n] beta_a;
  vector[n] beta_b;
  vector<lower=0>[n] lambda;
  real<lower=0> tau;
}
model {
  tau ~ cauchy(0, 1);
  lambda ~ cauchy(0, 1);
  beta_hat_a ~ normal(Sigma_a * beta_a, se_a);
  beta_hat_b ~ normal(Sigma_b * beta_b, se_b);
  for (i in 1:n) {
    beta_a[i] ~ normal(0, lambda[i] * tau);
    beta_b[i] ~ normal(0, lambda[i] * tau);
  }
}
\end{Verbatim}

\newpage

\subsection{Slope fitting step}

\texttt{inst/stan/slope.stan}

\begin{Verbatim}[frame=single,numbers=left]
data {
  int n; 
  vector[n] beta_hat_a;
  vector[n] beta_hat_b;
  vector[n] sd_a;
  vector[n] sd_b;
  real alpha_mu;
  real alpha_sd;
  real sigma_sd;
}
parameters {
  real alpha;
  real<lower=0> sigma;
  vector[n] beta_a;
  vector[n] beta_b;
}
model {
  beta_hat_a ~ normal(beta_a, sd_a);
  beta_hat_b ~ normal(beta_b, sd_b);
  beta_b ~ normal(alpha * beta_a, sigma);
  alpha ~ normal(alpha_mu, alpha_sd);
  sigma ~ normal(0, sigma_sd);
}
\end{Verbatim}

\newpage

\bibliography{main}
\end{document}
